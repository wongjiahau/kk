use crate::ast::*;
use crate::unify::UnifyError;
use std::cell::RefCell;
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct Environment<'a> {
    parent: Option<&'a Environment<'a>>,
    value_symbols: RefCell<HashMap<String, ValueSymbol>>,
    type_symbols: RefCell<HashMap<String, TypeSymbol>>,
    type_variable_index: usize,
    pub source: Source,
}

impl<'a> Environment<'a> {
    pub fn new_root(source: Source) -> Environment<'a> {
        Environment {
            parent: None,
            value_symbols: RefCell::new(HashMap::new()),
            type_symbols: RefCell::new(built_in_type_symbols()),
            type_variable_index: 0,
            source,
        }
    }

    pub fn new(parent: &'a Environment) -> Environment<'a> {
        Environment {
            source: parent.source.clone(),
            parent: Some(parent),
            value_symbols: RefCell::new(HashMap::new()),
            type_symbols: RefCell::new(HashMap::new()),
            type_variable_index: 0,
        }
    }

    pub fn resolve_type_alias(&self, type_value: Type) -> Result<Type, UnifyError> {
        match type_value {
            Type::Alias { name } => {
                // TODO: this is a weird hack
                let token = Token {
                    representation: name,
                    token_type: TokenType::Identifier,
                    position: Position {
                        column_start: 0,
                        column_end: 0,
                        line_start: 0,
                        line_end: 0,
                    },
                };
                self.resolve_type_alias(self.get_type_symbol(&token)?.type_value)
            }
            _ => Ok(type_value),
        }
    }

    fn get_next_type_variable_name(&mut self) -> String {
        format!("@TVAR{}", self.type_variable_index)
    }

    pub fn specialized_type_variable(&mut self, type_variable_name: String, to_type: Type) {
        let mut type_symbols = self.type_symbols.borrow_mut();
        type_symbols.insert(
            type_variable_name,
            TypeSymbol {
                declaration: Declaration::Unknown,
                type_value: to_type,
                usage_references: vec![],
            },
        );
    }

    pub fn instantiate_type_variable(&mut self) -> String {
        let name = self.get_next_type_variable_name();
        let mut type_symbols = self.type_symbols.borrow_mut();
        type_symbols.insert(
            name.clone(),
            TypeSymbol {
                declaration: Declaration::AutoGeneratedTypeVariable,
                type_value: Type::ImplicitTypeVariable { name: name.clone() },
                usage_references: vec![],
            },
        );
        name
    }

    pub fn introduce_type_variable(&mut self, variable_name: &Token) -> Result<Type, UnifyError> {
        let name = self.get_next_type_variable_name();
        self.type_variable_index += 1;
        let type_value = Type::ImplicitTypeVariable { name: name.clone() };
        self.insert_value_symbol(
            &variable_name,
            ValueSymbol {
                declaration: Declaration::UserDefined(self.source.clone(), variable_name.clone()),
                actual_type: type_value.clone(),
                usage_references: vec![],
            },
        )?;

        let mut type_symbols = self.type_symbols.borrow_mut();
        type_symbols.insert(
            name.clone(),
            TypeSymbol {
                declaration: Declaration::AutoGeneratedTypeVariable,
                type_value: type_value.clone(),
                usage_references: vec![],
            },
        );

        Ok(type_value)
    }

    pub fn insert_value_symbol(
        &mut self,
        token: &Token,
        value_symbol: ValueSymbol,
    ) -> Result<(), UnifyError> {
        let name = token.representation.clone();
        let mut value_symbols = self.value_symbols.borrow_mut();
        match value_symbols.get(&name) {
            Some(symbol) => Err(UnifyError::DuplicatedIdentifier {
                first_declared_at: symbol.declaration.clone(),
                then_declared_at: Declaration::UserDefined(self.source.clone(), token.clone()),
                name,
            }),
            None => {
                value_symbols.insert(name, value_symbol);
                Ok(())
            }
        }
    }

    pub fn get_type_symbol(&self, token: &Token) -> Result<TypeSymbol, UnifyError> {
        let name = token.representation.clone();
        if let Some(type_symbol) = self.type_symbols.borrow().get(&name) {
            Ok(type_symbol.clone())
        } else if let Some(parent) = &self.parent {
            parent.get_type_symbol(&token)
        } else {
            Err(UnifyError::UnknownTypeSymbol {
                location: Location {
                    source: self.source.clone(),
                    position: token.position.clone(),
                },
            })
        }
    }
    pub fn get_implicit_type_variables(&self) -> Vec<String> {
        self.type_symbols
            .borrow()
            .iter()
            .filter_map(|(name, type_symbol)| match type_symbol {
                TypeSymbol {
                    type_value: Type::ImplicitTypeVariable { .. },
                    ..
                } => Some(name.clone()),
                _ => None,
            })
            .into_iter()
            .collect()
    }

    pub fn get_value_symbol(&self, name: &String) -> Option<ValueSymbol> {
        if let Some(value_symbol) = self.value_symbols.borrow().get(name) {
            Some(value_symbol.clone())
        } else if let Some(parent) = &self.parent {
            parent.get_value_symbol(name)
        } else {
            None
        }
    }
}

#[derive(Debug, Clone)]
pub enum Declaration {
    Unknown,
    BuiltIn,
    AutoGeneratedTypeVariable,
    UserDefined(Source, Token),
}

#[derive(Debug, Clone)]
pub struct TypeSymbol {
    pub declaration: Declaration,
    pub type_value: Type,
    pub usage_references: Vec<UsageReference>,
}

#[derive(Debug, Clone)]
pub struct ValueSymbol {
    pub declaration: Declaration,
    pub actual_type: Type,
    pub usage_references: Vec<UsageReference>,
}

#[derive(Debug, Clone)]
pub struct UsageReference {
    position: Position,
    source: Source,
}

fn built_in_type_symbols() -> HashMap<String, TypeSymbol> {
    let mut hash_map = HashMap::new();
    hash_map.insert(
        "string".to_string(),
        TypeSymbol {
            declaration: Declaration::BuiltIn,
            type_value: Type::String,
            usage_references: vec![],
        },
    );
    hash_map.insert(
        "number".to_string(),
        TypeSymbol {
            declaration: Declaration::BuiltIn,
            type_value: Type::Number,
            usage_references: vec![],
        },
    );
    hash_map
}
